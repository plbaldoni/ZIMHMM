{
    "collab_server" : "",
    "contents" : "// [[Rcpp::depends(RcppArmadillo)]]\n#include <RcppArmadillo.h>\n// #include <RcppEigen.h>\n#include <numeric>\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// This is a simple function using Rcpp that creates an R list\n// containing a character vector and a numeric vector.\n//\n// Learn more about how to use Rcpp at:\n//\n//   http://www.rcpp.org/\n//   http://adv-r.had.co.nz/Rcpp.html\n//\n// and browse examples of code using Rcpp at:\n//\n//   http://gallery.rcpp.org/\n//\n\n// [[Rcpp::export]]\nList rcpp_hello() {\n  CharacterVector x = CharacterVector::create(\"foo\", \"bar\");\n  NumericVector y   = NumericVector::create(0.0, 1.0);\n  List z            = List::create(x, y);\n  return z;\n}\n\n//[[Rcpp::export]]\nNumericVector Viterbi(NumericMatrix LOGF, NumericVector P, NumericMatrix GAMMA){\n    int M = LOGF.nrow();\n    int K = LOGF.ncol();\n\n    NumericMatrix LOGV(M,K);\n    NumericMatrix V(M,K);\n\n    LOGV(0,_) = log(P) + LOGF(0,_);\n    V(0,_) = P*exp(LOGF(0,_));\n    V(0,_) = V(0,_)/sum(V(0,_));\n\n    NumericMatrix COND(K,K);\n    NumericMatrix MAXCOND(K);\n\n    for(int j = 0; j < (M-1); j++){\n        for(int k = 0; k < K; k++){\n            COND(k,_) = V(j,_)*GAMMA(_,k);\n            MAXCOND[k] = max(COND(k,_));\n        }\n        V(j+1,_) = MAXCOND*exp(LOGF(j+1,_));\n        V(j+1,_) = V(j+1,_)/sum(V(j+1,_));\n    }\n\n    NumericVector S(M);\n    NumericVector AUXS(K);\n    S[M-1] = which_max(V(M-1,_));\n\n    for(int j = (M-2); j >= 0; j--){\n        AUXS = V(j,_)*GAMMA(_,S[j+1]);\n        S[j] = which_max(AUXS);\n    }\n\n    return(S);\n}\n\n//[[Rcpp::export]]\nNumericVector hmm_logF(NumericVector logf1, NumericVector logf2, NumericVector pi, NumericMatrix gamma){\n    //f1 = background log-density evaluated at response vector\n    //f2 = enrichment log-density evaluated at response vector\n    //pi = probability vector\n    //gamma = transition probability\n\n    int N = logf1.size(); //Number of observations\n    int K = pi.size(); //Number of states\n\n    NumericMatrix logF(N,K); //Matrix f(i,k) (Equation A.1. JASA paper)\n    NumericMatrix F(N,K); //Matrix f(i,k) (Equation A.1. JASA paper)\n\n    //Initializing logF\n    logF(0,0) = log(pi[0]) + logf1[0];\n    logF(0,1) = log(pi[1]) + logf2[0];\n\n    //Forward loop\n    for(int i = 1; i < N; i++){\n        NumericVector a(2);\n        a(0) = logF(i-1,0) + log(gamma(0,0)) + logf1[i];\n        a(1) = logF(i-1,1) + log(gamma(1,0)) + logf1[i];\n        double maxa = max(a);\n\n        NumericVector c(2);\n        c(0) = logF(i-1,0) + log(gamma(0,1)) + logf2[i];\n        c(1) = logF(i-1,1) + log(gamma(1,1)) + logf2[i];\n        double maxc = max(c);\n\n        logF(i,0) = maxa + log(exp(a(0)-maxa)+exp(a(1)-maxa));\n        logF(i,1) = maxc + log(exp(c(0)-maxc)+exp(c(1)-maxc));\n    }\n    return logF;\n}\n\n//[[Rcpp::export]]\nNumericVector hmm_logB(NumericVector logf1, NumericVector logf2, NumericVector pi, NumericMatrix gamma){\n    //f1 = background log-density evaluated at response vector\n    //f2 = enrichment log-density evaluated at response vector\n    //pi = probability vector\n    //gamma = transition probability\n\n    int N = logf1.size(); //Number of observations\n    int K = pi.size(); //Number of states\n\n    NumericMatrix logB(N,K); //Matrix b(i,k) (Equation A.2. JASA paper)\n    NumericMatrix B(N,K); //Matrix b(i,k) (Equation A.2. JASA paper)\n\n    //Initializing logB\n    logB(N-1,0) = log(1);\n    logB(N-1,1) = log(1);\n\n    //Backward loop\n    for(int j = (N-2); j >= 0; j--){\n        NumericVector a(2);\n        a(0) = logB(j+1,0) + log(gamma(0,0)) + logf1[j+1];\n        a(1) = logB(j+1,1) + log(gamma(0,1)) + logf2[j+1];\n        double maxa = max(a);\n\n        NumericVector c(2);\n        c(0) = logB(j+1,0) + log(gamma(1,0)) + logf1[j+1];\n        c(1) = logB(j+1,1) + log(gamma(1,1)) + logf2[j+1];\n        double maxc = max(c);\n\n        logB(j,0) = maxa + log(exp(a(0)-maxa) + exp(a(1)-maxa));\n        logB(j,1) = maxc + log(exp(c(0)-maxc) + exp(c(1)-maxc));\n    }\n    return logB;\n}\n\n//[[Rcpp::export]]\nNumericVector hmm_P1(NumericMatrix logF, NumericMatrix logB){\n    int N = logF.nrow(); //Number of observations\n    int K = logF.ncol(); //Number of states\n\n    NumericMatrix logP(N,K); //Final probability matrix (output)\n    NumericMatrix P(N,K); //Final probability matrix (output)\n\n    NumericVector d(2);\n    d(0) = logF(N-1,0);\n    d(1) = logF(N-1,1);\n    double maxd = max(d);\n\n    //Output loop\n    for(int i = 0; i < N;i++){\n        for(int j = 0; j < K; j++){\n            logP(i,j) = logF(i,j) + logB(i,j) - maxd - log(exp(d(0)-maxd) + exp(d(1)-maxd));\n            P(i,j) = exp(logP(i,j));\n        }\n    }\n    return P;\n}\n\n//[[Rcpp::export]]\nNumericVector hmm_P2(NumericMatrix logF, NumericMatrix logB,NumericVector logf1, NumericVector logf2, NumericMatrix gamma){\n    //f1 = background log-density evaluated at response vector\n    //f2 = enrichment log-density evaluated at response vector\n    //pi = probability vector\n    //gamma = transition probability\n\n    int N = logF.nrow(); //Number of observations\n    int K = logF.ncol(); //Number of states\n\n    NumericMatrix logP(N,K*K); //Final probability matrix (output)\n    NumericMatrix P(N,K*K); //Final probability matrix (output)\n\n    NumericVector d(2);\n    d(0) = logF(N-1,0);\n    d(1) = logF(N-1,1);\n    double maxd = max(d);\n\n    //Output loop\n    for(int i = 0; i < N;i++){\n        if(i >= 1){\n            logP(i,0) = logF(i-1,0) + log(gamma(0,0)) + logf1[i] + logB(i,0) - maxd - log(exp(d(0)-maxd) + exp(d(1)-maxd));\n            logP(i,1) = logF(i-1,0) + log(gamma(0,1)) + logf2[i] + logB(i,1) - maxd - log(exp(d(0)-maxd) + exp(d(1)-maxd));\n            logP(i,2) = logF(i-1,1) + log(gamma(1,0)) + logf1[i] + logB(i,0) - maxd - log(exp(d(0)-maxd) + exp(d(1)-maxd));\n            logP(i,3) = logF(i-1,1) + log(gamma(1,1)) + logf2[i] + logB(i,1) - maxd - log(exp(d(0)-maxd) + exp(d(1)-maxd));\n\n            P(i,0) = exp(logP(i,0));\n            P(i,1) = exp(logP(i,1));\n            P(i,2) = exp(logP(i,2));\n            P(i,3) = exp(logP(i,3));\n        }\n    }\n    //1st col = P(1,1), 2nd col = P(1,2), 3rd col = P(2,1), 4th col = P(2,2)\n    return P;\n}\n\n//[[Rcpp::export]]\narma::mat my_dnbinom(arma::mat x, arma::mat mu, double size, int lg){\n    int M = x.size();\n    arma::mat out(M,1);\n    for(int i = 0; i < M; i++){\n        out(i,0) = R::dnbinom_mu(x[i],size,mu[i],lg);\n    }\n    return(out);\n}\n\n//[[Rcpp::export]]\narma::mat MHMMmean(arma::mat XMAT, arma::mat BETA, arma::mat RANDOM, arma::mat OFFSETVEC, int N, int M, int K)\n{\n    arma::mat MU(M,K*N); //Final mean matrix\n\n    int index = 0;\n    for(int i = 0; i < N; i++){\n        int from = i*M;\n        int to = from + (M - 1);\n        arma::mat subXMAT = XMAT.rows(from,to);\n        arma::mat subRANDOM = RANDOM.rows(from,to);\n        arma::mat subOFFSETVEC = OFFSETVEC.rows(from,to);\n        for(int k = 0; k < K; k++){\n            arma::mat subBETA = BETA.row(k);\n            arma::mat subMU = exp(subXMAT*subBETA.t()+subRANDOM+subOFFSETVEC);\n            MU.col(index) = subMU;\n            index++;\n        }\n    }\n    return MU;\n}\n\n//[[Rcpp::export]]\narma::mat MHMMLik(arma::vec YVEC, arma::mat ZEROINFL, arma::mat MU, arma::vec DISP,int N, int M, int K){\n    arma::mat LL(M,K); LL.zeros();\n\n    //NumericVector onevec(M,1.0);\n    //NumericVector zerovec(M,0.0);\n    //NumericMatrix wrap_YVEC = wrap(YVEC);\n\n    //arma::mat YVEC0 = ifelse(wrap_YVEC==zerovec,onevec,zerovec);\n    arma::mat YVEC0(N*M,1); YVEC0.zeros();\n    arma::uvec ids = find(YVEC == 0);\n    YVEC0.rows(ids).fill(1);\n    arma::mat ZEROINFLvec(M*N,1); ZEROINFLvec.col(0) = vectorise(ZEROINFL);\n\n    //Background\n    NumericVector idxNV = wrap(seq(0,(N-1))); idxNV = idxNV*K;\n    arma::uvec idx = as<arma::uvec>(idxNV);\n    arma::mat muidx(M*N,1); muidx.col(0) = vectorise(MU.cols(idx));\n    arma::mat zeroidx(N*M,1); zeroidx.zeros();\n    arma::mat LogLik00(N*M,1); LogLik00.col(0) = my_dnbinom(zeroidx,muidx,DISP[0],1);\n    arma::mat LogLik01(N*M,1); LogLik01.col(0) = my_dnbinom(YVEC,muidx,DISP[0],1);\n\n    arma::mat LLvecaux(N*M,1); LLvecaux.col(0) = YVEC0%log(ZEROINFLvec + exp(log(1-ZEROINFLvec)+LogLik00)) + (1-YVEC0)%(log(1-ZEROINFLvec) + LogLik01);\n    arma::mat LLmataux = reshape(LLvecaux,M,N);\n    NumericMatrix LLmataux1 = wrap(LLmataux);\n    arma::mat LLmataux2 = rowSums(LLmataux1);\n    LL.col(0) = LLmataux2;\n\n    //Enrichment\n    idxNV = idxNV + 1;\n    idx = as<arma::uvec>(idxNV);\n    muidx.col(0) = vectorise(MU.cols(idx));\n    arma::mat LogLik1(N*M,1); LogLik1.col(0) = my_dnbinom(YVEC,muidx,DISP[1],1);\n    LLmataux = reshape(LogLik1,M,N);\n    LLmataux1 = wrap(LLmataux);\n    LLmataux2 = rowSums(LLmataux1);\n    LL.col(1) = LLmataux2;\n\n    return(LL);\n}\n\n// [[Rcpp::export]]\ndouble integrand(NumericVector U, arma::vec YVEC, arma::mat XMAT, arma::mat BETA, arma::vec DISP,\n                 NumericVector P, NumericMatrix GAMMA, arma::vec OFFSETVEC,\n                 arma::mat ZEROINFL,NumericVector W, double SIGMA2){\n\n    int N = U.size();\n    int M = YVEC.size()/N;\n    int K = P.size();\n\n    NumericVector RANDOMrcpp = sqrt(SIGMA2)*rep_each(U,M)*W;\n    arma::mat RANDOM(N*M,1); RANDOM = as<arma::vec>(RANDOMrcpp);\n\n    arma::mat MU = MHMMmean(XMAT,BETA,RANDOM,OFFSETVEC,N,M,K);\n    arma::mat LogLik = MHMMLik(YVEC,ZEROINFL,MU,DISP,N,M,K);\n\n    NumericVector logFj1(K);\n    NumericVector logFj2(K);\n    NumericMatrix Bj1(K,K);\n    NumericMatrix Bj2(K,K);\n    NumericMatrix Bj(K,K);\n\n    for(int j = 2; j < M; j++){\n        if(j==2){\n            logFj1(0) = LogLik(j-1,0);//R::dnbinom_mu(Y[j-1],PHI[0],exp(B0[0]+B1[0]*X[j-1]+U),1);\n            logFj1(1) = LogLik(j-1,1);//R::dnbinom_mu(Y[j-1],PHI[1],exp(B0[1]+B1[1]*X[j-1]+U),1);\n            Bj1(0,0) = log(GAMMA(0,0)) + logFj1[0];Bj1(0,1) = log(GAMMA(0,1)) + logFj1[1];\n            Bj1(1,0) = log(GAMMA(1,0)) + logFj1[0];Bj1(1,1) = log(GAMMA(1,1)) + logFj1[1];\n        } else{\n            arma::mat Bj1 = log(as<arma::mat>(clone(Bj)));\n        }\n\n        logFj2(0) = LogLik(j,0);//R::dnbinom_mu(Y[j],PHI[0],exp(B0[0]+B1[0]*X[j]+U),1);\n        logFj2(1) = LogLik(j,1);//R::dnbinom_mu(Y[j],PHI[1],exp(B0[1]+B1[1]*X[j]+U),1);\n        Bj2(0,0) = log(GAMMA(0,0)) + logFj2[0];Bj2(0,1) = log(GAMMA(0,1)) + logFj2[1];\n        Bj2(1,0) = log(GAMMA(1,0)) + logFj2[0];Bj2(1,1) = log(GAMMA(1,1)) + logFj2[1];\n\n        Bj(0,0) = exp(Bj1(0,0)+Bj2(0,0)) + exp(Bj1(0,1)+Bj2(1,0));\n        Bj(0,1) = exp(Bj1(0,0)+Bj2(0,1)) + exp(Bj1(0,1)+Bj2(1,1));\n        Bj(1,0) = exp(Bj1(1,0)+Bj2(0,0)) + exp(Bj1(1,1)+Bj2(1,0));\n        Bj(1,1) = exp(Bj1(1,0)+Bj2(0,1)) + exp(Bj1(1,1)+Bj2(1,1));\n    }\n    NumericVector A(2);\n    A[0] = log(P[0]) + LogLik(0,0);//R::dnbinom_mu(Y[0],PHI[0],exp(B0[0]+B1[0]*X[0]+U),1);\n    A[1] = log(P[1]) + LogLik(0,1);//R::dnbinom_mu(Y[0],PHI[1],exp(B0[1]+B1[1]*X[0]+U),1);\n\n    NumericVector AB(2);\n    AB[0] = exp(A[0]+log(Bj(0,0)))+exp(A[1]+log(Bj(1,0)));\n    AB[1] = exp(A[0]+log(Bj(0,1)))+exp(A[1]+log(Bj(1,1)));\n\n    double result = log(sum(AB)) + sum(dnorm(U,0.0,1.0,1));\n    return(result);\n}\n\n//[[Rcpp::export]]\nNumericVector generateHMM(NumericMatrix GAMMA,int m){\n    //generateHMM simulates a Markov Chain given a matrix of transition probabilities\n    //This function simulates a sequence of hidden states Z based on the transition probabilities GAMMA\n    //This function is used when simulating data\n    NumericVector Z(m,0.0);\n    Z[0] = 1;\n    for(int i = 1; i < m; i ++)\n    {\n        double rand = R::runif(0,1);\n        double sump = 0;\n        int flag = 0;\n        int k = 0;\n        while(flag == 0){\n            sump = sump + GAMMA((Z[i-1]-1),k);\n            if(rand<=sump){\n                Z[i] = (k+1);\n                flag++;\n            }\n            k++;\n        }\n    }\n    return Z;\n}\n\n",
    "created" : 1550869696253.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "21|19|26|0|\n29|80|62|0|\n65|104|97|0|\n100|104|132|0|\n135|61|155|0|\n158|123|191|0|\n194|69|201|0|\n",
    "hash" : "2341097704",
    "id" : "C0E3A16C",
    "lastKnownWriteTime" : 1551729745,
    "last_content_update" : 1551729745009,
    "path" : "~/Dropbox/PhD/Research/Project1/ZIMHMM/src/codes.cpp",
    "project_path" : "src/codes.cpp",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "cpp"
}